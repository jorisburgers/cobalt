data 'Example a;
data 'Expr a;

import nil    :: {a} [a];
import cons   :: {a} a -> [a] -> [a];
import tuple  :: {a} {b} a -> b -> (a,b);

import exampleInt  :: 'Integer -> 'Example 'Integer;
import exampleBool :: 'Bool    -> 'Example 'Bool;

import fix :: {a} {x = a -> a} x -> a;

import zero :: 'Integer;
import succ :: 'Integer -> 'Integer;
import plus :: 'Integer -> 'Integer -> 'Integer;
import mult :: 'Integer -> 'Integer -> 'Integer;
import gte  :: 'Integer -> 'Integer -> 'Bool;

import ifte :: {a} Bool -> a -> a -> a;

import intLit   :: 'Integer -> 'Expr 'Integer;
import gteE     :: 'Expr 'Integer -> 'Expr 'Integer -> 'Expr Bool;
import ifteE    :: {a} 'Expr 'Bool -> 'Expr a -> 'Expr a -> 'Expr a;
import evalBool :: 'Expr 'Bool -> 'Bool;

headOrZero = \x -> match x with 'List
                   | nil -> 0
                   | cons x xs -> x => ok;

example :: {a} 'Example a -> 'Integer
         = \x -> match x with 'Example
                 | exampleInt  x -> x
                 | exampleBool b -> 8 => ok;

appendA = \a -> \x -> \y -> match x with 'List
                            | nil -> y
                            | cons z zs -> cons z (a zs y) => ok;
append = fix appendA => ok;

factorial = fix (\f -> \n -> match n with 'Integer
                             | zero -> 1
                             | succ x -> mult (plus x 1) (f x)) => ok;

eval :: 'Expr 'Integer -> 'Integer
  = fix (\e -> \expr -> match expr with 'Expr
                        | intLit x -> x
                        | ifteE b x y -> ifte (evalBool b) (e x) (e y)) => ok;
evalWithoutSignature = fix (\e -> \expr -> match expr with 'Expr
                                           | intLit x -> x
                                           | ifteE b x y -> ifte (evalBool b) (e x) (e y)) => fail;