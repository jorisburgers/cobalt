import execute :: {a} 'Expr a -> a;
import plus :: {a} 'Expr a -> 'Expr a -> 'Expr a;
import mult :: {a} 'Expr a -> 'Expr a -> 'Expr a;
import lit  :: {a} $Num a => a -> 'Expr a;

axiom $Num 'Int;
axiom $Num 'Float;

import anInt  :: 'Int;
import aFloat :: 'Float;
import true   :: 'Bool;
import false  :: 'Bool;

f1 = execute (plus (mult (lit 3) (lit 2)) (lit 5));
f2 = execute (plus (mult (lit aFloat) (lit aFloat)) (lit aFloat));
f3 = execute (plus (mult (lit 3) (lit 2)) (lit aFloat));
f4 = execute (plus (mult (lit true) (lit 2)) (lit true));

rule   unsafe look_at_leaves
match  app (var "execute") [ #ap1@(app #ap2@(app #op@(var "plus") &k) &k)
                           | #ap1@(app #ap2@(app #op@(var "mult") &k) &k)
                           | #ap1@(app #lit@(var "lit") #leaf) ]*k
script      (merge #leaf)
       asym "All literals must be of the same type"
            (merge #leaf ~ e)
       asym "Literals must be of class Num"
            $Num e
       asym (merge [ merge #ap1 ~ 'Expr e, merge #ap2 ~ 'Expr e -> 'Expr e ])
       asym (merge [ merge #op, merge #lit ])
       asym #this ~ e;
