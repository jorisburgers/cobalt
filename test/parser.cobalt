import dullar :: {a} {b} {s} (a -> b) -> 'Parser s a -> 'Parser s b;
import star   :: {a} {b} {s} 'Parser s (a -> b) -> 'Parser s a -> 'Parser s b;

rule   app_parser
match  #first@(#dollar@(dullar) #fn) #arg
script var #a1 #a2 #b1 #b2 #s1 #s2,
       #dollar ~ (#a1 -> #b1) -> 'Parser #s1 #a1 -> 'Parser #s1 #b1,
       #first  ~ 'Parser #s1 #a1 -> 'Parser #s1 #b1,
       constraints #fn,
       merge blame last,
       #fn ~ #a1 -> #b1 { "left operand must be a function" },
       merge blame last { "Left operand is not a function" },
       constraints #arg,
       merge blame last,
       #arg ~ 'Parser #s1 #a2 { "right operand must be a parser" },
       merge blame last { "Right operand is not a parser" },
       #this ~ 'Parser #s2 #b2,
       merge blame last { "Context does not accept a parser" },
       #b1 ~ #b2 { "the result type must be as expected" },
       merge blame last { "Parser has an incorrect result type" },
       #a1 ~ #a2 { "function should be applied to parser's result" },
       merge blame last { "Function cannot be applied to parser's result" },
       #s1 ~ #s2 { "parser symbols must coincide" },
       merge blame last { "Parser has an incorrect symbol type" };

import mapToUpper :: [a] -> [a];
import helloWorld :: 'String;
import definitelyNotAFunction :: 'Bool;

import parser1 :: 'Parser 'String ['Int];
import parser2 :: 'Parser 'String 'Bool;

test1 = dullar mapToUpper helloWorld => fail;
test2 = dullar definitelyNotAFunction parser1 => fail;
test3 = dullar definitelyNotAFunction helloWorld => fail;
test4 = dullar mapToUpper parser1;
test5 = dullar mapToUpper parser2 => fail;


rule unsafe mega_app_parser
match  #oOne@(#oStar@(star)
              [ #firstTwo@(#firstOne@(#dullar@(dullar) #fn) #x)
              | #two@(#one@(#star@(star) &k) #y)]*k)
             #z
script var #tau #w1 #w2 #w3 #str #f1 #f2 #f3 #f4,
       constraints #fn,
       update #tau <- #w1 -> #w2,
       foreach #i <- #y { var #w, update #tau <- #w -> #tau },
       update #tau <- #w3 -> #tau,
       #fn ~ #tau,
       merge blame last { "function does not have enough arguments" },

       localstack {
         constraints #x,
         #x > {s} {a} 'Parser s a,
         merge 2 blame last { "first argument is not a parser" },

         foreach #i <- #y {
           constraints #i,
           #i > {s} {a} 'Parser s a,
           merge 2 blame last { "argument is not a parser" }
         },

         constraints #z,
         #z > {s} {a} 'Parser s a,
         merge 2 blame last { "last argument is not a parser" }
       },
       merge blame last,

       localstack {
         #x > {a} 'Parser #str a,
         foreach #i <- #y { #i > {a} 'Parser #str a },
         #z > {a} 'Parser #str a
       },
       merge blame last { "not all parsers consume the same type" },

       #tau ~ #f1 -> #f2,
       #x   ~ 'Parser #str #f1,
       merge blame last { "first parser does not produce the correct type" },
       #dullar   ~ (#f1 -> #f2) -> 'Parser #str #f1 -> 'Parser #str #f2,
       #firstOne ~ 'Parser #str #f1 -> 'Parser #str #f2,
       #firstTwo ~ 'Parser #str #f2,
       merge blame last 3,

       update #tau <- #f2,
       foreach #i #s #o #t <- #y #star #one #two {
         var #t1 #t2,
         #tau ~ #t1 -> #t2,
         #i ~ 'Parser #str #t1,
         merge blame last { "parser does not produce the correct type" },
         #s ~ 'Parser #str (#t1 -> #t2) -> 'Parser #str #t1 -> 'Parser #str #t2,
         #o ~ 'Parser #str #t1 -> 'Parser #str #t2,
         #t ~ 'Parser #str #t2,
         merge blame last 3,
         update #tau <- #t2
       },

       #tau ~ #f3 -> #f4,
       #z   ~ 'Parser #str #f3,
       merge blame last 2 { "last parser does not produce the correct type" },
       #oStar ~ 'Parser #str (#f3 -> #f4) -> 'Parser #str #f3 -> 'Parser #str #f4,
       #oOne  ~ 'Parser #str #f3 -> 'Parser #str #f4,
       #this  ~ 'Parser #str #f4,
       merge blame last 3;

import twoArgFn   :: ['Int] -> 'Bool -> 'Result;
import threeArgFn :: ['Int] -> 'Bool -> 'Bool -> 'Result;

testA = star (dullar twoArgFn parser1) parser2;
testB = star (dullar twoArgFn parser1) parser1 => fail;
testC = star (dullar twoArgFn parser2) parser1 => fail;
testD = star (star (dullar twoArgFn   parser2) parser1) parser1 => fail;
testE = star (star (dullar threeArgFn parser1) parser2) parser1 => fail;
