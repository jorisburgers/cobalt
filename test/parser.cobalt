import dullar :: {a} {b} {s} (a -> b) -> 'Parser s a -> 'Parser s b;
import star   :: {a} {b} {s} 'Parser s (a -> b) -> 'Parser s a -> 'Parser s b;

rule   app_parser
match  #first@(#dollar@(dullar) #fn) #arg
script fresh #a1 #a2 #b1 #b2 #s1 #s2,
       [ #dollar ~ (#a1 -> #b1) -> 'Parser #s1 #a1 -> 'Parser #s1 #b1,
         #first  ~ 'Parser #s1 #a1 -> 'Parser #s1 #b1 ],
       constraints #fn,
       #fn ~ #a1 -> #b1        error { "Left operand is not a function" },
       constraints #arg,
       #arg ~ 'Parser #s1 #a2  error { "Right operand is not a parser" },
       #this ~ 'Parser #s2 #b2 error { "Context does not accept a parser" },
       #b1 ~ #b2               error { "Parser has an incorrect result type" },
       #a1 ~ #a2               error { "Function cannot be applied to parser's result" },
       #s1 ~ #s2               error { "Parser has an incorrect symbol type" };

import mapToUpper :: [a] -> [a];
import helloWorld :: 'String;
import definitelyNotAFunction :: 'Bool;

import parser1 :: 'Parser 'String ['Int];
import parser2 :: 'Parser 'String 'Bool;

test1 = dullar mapToUpper helloWorld => fail;
test2 = dullar definitelyNotAFunction parser1 => fail;
test3 = dullar definitelyNotAFunction helloWorld => fail;
test4 = dullar mapToUpper parser1;
test5 = dullar mapToUpper parser2 => fail;


rule unsafe mega_app_parser
match  #oOne@(#oStar@(star)
              [ #firstTwo@(#firstOne@(#dullar@(dullar) #fn) #x)
              | #two@(#one@(#star@(star) &k) #y)]*k)
             #z
script constraints #fn,

       fresh #w1 #w2 #w3,
       fold #i <- inout #y init #tau <- #w1 -> #w2 { fresh #w } next #w -> #tau,
       #fn ~ #w3 -> #tau error { "Function has too many arguments" },

       [ asym [ constraints #x,
                #x > {s} {a} 'Parser s a error { "First argument is not a parser" }],
         asym [ constraints #i,
                #i > {s} {a} 'Parser s a error { "Argument is not a parser" }
              | #i <- inout #y ],
         asym [ constraints #z,
                #z > {s} {a} 'Parser s a error { "Last argument is not a parser" }] ],

       fresh #str,
       [ #x > {a} 'Parser #str a,
         [ #i > {a} 'Parser #str a | #i <- inout #y ],
         #z > {a} 'Parser #str a
       ] error { "Not all parsers consume the same type" },

       fresh #f1 #f2,
       [ #fn ~ #f1 -> #f2,
         #x  ~ 'Parser #str #f1,
         #dullar   ~ (#f1 -> #f2) -> 'Parser #str #f1 -> 'Parser #str #f2,
         #firstOne ~ 'Parser #str #f1 -> 'Parser #str #f2,
         #firstTwo ~ 'Parser #str #f2 ]
       error { "First parser does not produce the correct type" },

       fold #i <- inout #y | #s <- inout #star | #o <- inout #one | #t <- inout #two
       init #ty <- #f2 {
         fresh #f3 #f4,
         #ty ~ #f3 -> #f4,
         #i ~ 'Parser #str #f3,
         #s ~ 'Parser #str (#f3 -> #f4) -> 'Parser #str #f3 -> 'Parser #str #f4,
         #o ~ 'Parser #str #f3 -> 'Parser #str #f4,
         #t ~ 'Parser #str #f4
       } next #f4,

       fresh #f5 #f6,
       [ #ty ~ #f5 -> #f6,
         #z  ~ 'Parser #str #f5,
         #oStar ~ 'Parser #str (#f5 -> #f6) -> 'Parser #str #f5 -> 'Parser #str #f6,
         #oOne  ~ 'Parser #str #f5 -> 'Parser #str #f6,
         #this  ~ 'Parser #str #f6 ]
       error { "Last parser does not produce the correct type" };


import twoArgFn   :: ['Int] -> 'Bool -> 'Result;
import threeArgFn :: ['Int] -> 'Bool -> 'Bool -> 'Result;

testA = star (dullar twoArgFn parser1) parser2;
testB = star (dullar twoArgFn parser1) parser1 => fail;
testC = star (dullar twoArgFn parser2) parser1 => fail;
testD = star (star (dullar twoArgFn   parser2) parser1) parser1 => fail;
testE = star (star (dullar threeArgFn parser1) parser2) parser1 => fail;
testF = star (dullar twoArgFn 1) parser2 => fail;
testG = star (star (dullar threeArgFn parser1) parser1) parser1 => fail;
