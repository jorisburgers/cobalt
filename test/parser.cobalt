import dullar :: {a} {b} {s} (a -> b) -> 'Parser s a -> 'Parser s b;
import star   :: {a} {b} {s} 'Parser s (a -> b) -> 'Parser s a -> 'Parser s b;

rule app_parser
match  #first@(#dollar@(dullar) #fn) #arg
script var #a1 #a2 #b1 #b2 #s1 #s2,
       #dollar ~ (#a1 -> #b1) -> 'Parser #s1 #a1 -> 'Parser #s1 #b1,
       #first  ~ 'Parser #s1 #a1 -> 'Parser #s1 #b1,
       constraints #fn,
       merge blame last,
       #fn ~ #a1 -> #b1 { "left operand must be a function" },
       merge blame last { "Left operand is not a function" },
       constraints #arg,
       merge blame last,
       #arg ~ 'Parser #s1 #a2 { "right operand must be a parser" },
       merge blame last { "Right operand is not a parser" },
       #this ~ 'Parser #s2 #b2,
       merge blame last { "Context does not accept a parser" },
       #b1 ~ #b2 { "the result type must be as expected" },
       merge blame last { "Parser has an incorrect result type" },
       #a1 ~ #a2 { "function should be applied to parser's result" },
       merge blame last { "Function cannot be applied to parser's result" },
       #s1 ~ #s2 { "parser symbols must coincide" },
       merge blame last { "Parser has an incorrect symbol type" };

import mapToUpper :: [a] -> [a];
import helloWorld :: 'String;
import definitelyNotAFunction :: 'Bool;

import parser1 :: 'Parser 'String ['Int];
import parser2 :: 'Parser 'String 'Bool;

test1 = dullar mapToUpper helloWorld => fail;
test2 = dullar definitelyNotAFunction parser1 => fail;
test3 = dullar definitelyNotAFunction helloWorld => fail;
test4 = dullar mapToUpper parser1;
test5 = dullar mapToUpper parser2 => fail;
