rule   three_is_integer
match  3
script #this ~ 'Int { "3 is a number" };

import example :: 'Int -> 'Bool;

rule   example_unsound_rule
match  example #thing
script constraints #thing,
       #thing ~ 'Int { "argument must be an Int" },
       merge blame last;

f x y = x y (example 3);

g = z w => fail;

h x = 3 x => fail;


import singleton :: {a} a -> [a];

rule strict singleton_on_eq
match  #singl@(singleton) #thing
check  $Eq #thing
script #this ~ [#thing] { "singleton on Eq" },
       constraints #thing,
       constraints #singl,
       merge;

axiom $Eq 'Int;

u = singleton 3;
v :: {a} $Eq a => a -> [a] = \x -> singleton x;
w = singleton 3 4 => fail;
import aNonEq :: 'NonEqThingy;
t = singleton aNonEq;


import noRule :: 'Bool -> 'Int;

rule   make_rule
match  #fn@(noRule) #arg
script constraints #fn,
       constraints #arg,
       #this ~ 'Int,
       #arg ~ 'Bool,
       merge { "The error is here!" };

z = noRule 3 => fail;


import map :: {a} {b} (a -> b) -> [a] -> [b];

rule   map
match  #intermediate@(#map@(map) #fn) #list
script var #e #x #r,
       constraints #map,
       constraints #fn,
       constraints #list,
       merge,
       #list ~ [#e],
       merge blame last { "Second argument to map must be a list" },
       #fn ~ #x -> #r,
       merge blame last { "First argument to map must be a function" },
       #x ~ #e,
       merge blame last { "The function does not have the correct domain" },
       #intermediate ~ [#e] -> [#r],
       #this ~ [#r],
       merge;

import listOfInt  :: ['Int];
import fnOfInt    :: 'Int -> 'IntResult;
import listOfBool :: ['Bool];
import fnOfBool   :: 'Bool -> 'BoolResult;

example1 = map fnOfBool listOfInt => fail;


import by :: {a} $Fractional a => a -> a -> a;
axiom $Fractional 'Float;
axiom $Integral   'Int;

rule   divide_integers
match  by #n #m
check  $Integral #n, $Integral #m
script repair { "Use `div' or `quot' to divide integers" };

by1 = by 3 2 => fail;
