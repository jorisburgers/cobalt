rule three_is_integer
match  int 3
script #this ~ 'Int "3 is a number";

import example :: 'Int -> 'Bool;

rule   example_rule
match  app (var "example") #thing
script asym (#thing ~ 'Int "argument must be an Int")
            #thing;

f x y = x y (example 3);

g = z w => fail;

h x = 3 x => fail;


import singleton :: {a} a -> [a];

rule strict singleton_on_eq
match  app #singl@(var "singleton") #thing
check  $Eq #thing
script merge [ #this ~ [#thing] "singleton on Eq"
             , #thing
             , #singl ];

axiom $Eq 'Int;

u = singleton 3;
v :: {a} $Eq a => a -> [a] = \x -> singleton x;
w = singleton 3 4 => fail;


import noRule :: 'Bool -> 'Int;

rule  make_rule
match app #fn@(var "noRule") #arg
script merge "The error is here!"
             [ #fn, #arg, #this ~ 'Int, #arg ~ 'Bool];

z = noRule 3;


import map :: {m} {a} {b} $Functor m => (a -> b) -> 'App m a -> 'App m b;

axiom $Functor 'List;
axiom $Functor 'Maybe;

import plusThree :: 'Int -> 'Int;
import listOfInts :: 'App 'List 'Int;

f = map plusThree;
g = map plusThree listOfInts;

import map2 :: {m} {a} {b} $Functor m => (a -> b) -> 'App m a -> 'App m b;

rule map2_on_lists
match app #app1@(app #map2@(var "map2") #fn) #arg
script asym (merge [ a1 ~ a2, a2 ~ a3, b1 ~ b2, b ~ b2])
       asym #this ~ 'App 'List b
       asym "Parameters must coincide"
            a3 ~ a4
       asym "First argument should be a function"
            #fn ~ a4 -> b
       asym #fn
       asym "Second should be a list"
            (#arg ~ 'App 'List a3)
       asym #arg
       merge [ #map2 ~ (a2 -> b2) -> 'App 'List a2 -> 'App 'List b2
             , #app1 ~ 'App 'List a1 -> 'App 'List b1 ];

import maybeOfInts :: 'App 'Maybe 'Int;
import listOfBool :: 'App 'List 'Bool;

test0 = map2 plusThree;
test1 = map2 plusThree listOfInts;
test2 = map2 plusThree listOfBool => fail;
test3 = map2 plusThree maybeOfInts => fail;