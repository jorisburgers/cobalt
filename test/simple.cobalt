rule three_is_integer
match  int 3
script #this ~ 'Int "3 is a number";

import example :: 'Int -> 'Bool;

rule   example_unsound_rule
match  app (var "example") #thing
script asym (#thing ~ 'Int "argument must be an Int")
            #thing;

f x y = x y (example 3);

g = z w => fail;

h x = 3 x => fail;


import singleton :: {a} a -> [a];

rule strict singleton_on_eq
match  app #singl@(var "singleton") #thing
check  $Eq #thing
script merge [ #this ~ [#thing] "singleton on Eq"
             , #thing
             , #singl ];

axiom $Eq 'Int;

u = singleton 3;
v :: {a} $Eq a => a -> [a] = \x -> singleton x;
w = singleton 3 4 => fail;
import aNonEq :: 'NonEqThingy;
t = singleton aNonEq;


import noRule :: 'Bool -> 'Int;

rule  make_rule
match app #fn@(var "noRule") #arg
script merge "The error is here!"
             [ #fn, #arg, #this ~ 'Int, #arg ~ 'Bool];

z = noRule 3;


import map :: {a} {b} (a -> b) -> [a] -> [b];

rule   map
match  app #intermediate@(app #map@(var "map") #fn) #list
script asym (merge [ #intermediate ~ [e] -> [r], #this ~ [r] ])
       asym "The function does not have the correct domain"
            x ~ e
       asym "First argument to map must be a function"
            #fn ~ x -> r
       asym "Second argument to map must be a list"
            #list ~ [e]
       merge [ #map, #fn, #list ];

import listOfInt  :: ['Int];
import fnOfInt    :: 'Int -> 'IntResult;
import listOfBool :: ['Bool];
import fnOfBool   :: 'Bool -> 'BoolResult;

example1 = map fnOfBool listOfInt;


import by :: {a} $Fractional a => a -> a -> a;
axiom $Fractional 'Float;
axiom $Integral   'Int;

rule   divide_integers
match  app (app (var "by") #n) #m
check  $Integral #n, $Integral #m
script _|_ "Use `div' or `quot' to divide integers";

by1 = by 3 2 => fail;
