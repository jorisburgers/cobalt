import nil    :: {a} [a];
import cons   :: {a} a -> [a] -> [a];
import tuple  :: {a} {b} a -> b -> (a,b);
import fst    :: {a} {b} (a,b) -> a;
import snd    :: {a} {b} (a,b) -> b;
import triple :: {a} {b} {c} a -> b -> c -> 'Triple a b c;
import triplx :: {a} {b = {x} x} {c} a -> b -> c -> 'Triple a b c;
import tripla :: {a} {b > {x} x -> x} {c} a -> b -> c -> 'Triple a b c;
import sing   :: {a} a -> [a];
import id     :: {a} a -> a;

import bindST    :: {a} {b} {s} {t = a -> 'ST s b} 'ST s a -> t -> 'ST s b;
import runST     :: {a} {s = {s} 'ST s a} s -> a;
import newSTRef  :: {a} {s} a -> 'ST s ('STRef s a);
import readSTRef :: {a} {s} 'STRef s a -> 'ST s a;
import zas       :: {s} 'ST s 'Integer;

import f      :: {b} {s = {a} [a] -> b} s -> 'Bool -> b;
import length :: {a} [a] -> 'Integer;

checkFunParam1 = \x -> \(y :: {a} a -> a) -> cons (x (tuple y 3)) nil => ok;
checkFunParam2 = \(x :: {a} a -> a) -> \y -> cons (x (tuple y 3)) nil => ok;
checkFunApp1 = \x -> \y -> cons (x (tuple y 3)) nil                   => ok;
checkFunApp2 = \x -> \y -> cons (x y) nil                             => ok;
checkNoChanges = tuple                                                => ok;

instErr1 = cons 3 2                                         => fail;
idRoundtrip = \x -> fst (tuple x 3)                         => ok;
instType1 = \x -> \y -> triple x y 3                        => ok;
instType2 = \x -> \(y :: {b} b) -> triplx x y 3             => ok;
instType3Err = \x -> \(y :: {b} b -> b) -> triplx x y 3     => fail;
instType4Err = \x -> \(y :: 'Integer) -> triplx x y 3       => fail;
instType5 = \x -> \(y :: {b} b -> b) -> tripla x y 3        => ok;
instType6Err = \x -> \(y :: 'Integer) -> tripla x y 3       => fail;
instType7 = \x -> \(y :: {b} 'Integer -> b) -> tripla x y 3 => ok;

singBis = \x -> cons x nil    => ok;
idBis = \x -> x               => ok;
intRoundtrip = let x = 3 in x => ok;

singId1 = sing id                                               => ok;
singId2 :: {a = {b} b -> b} [a] = let x = sing id in x          => ok;
singId3 :: {a > {b} b -> b} [a] = let x = sing id in x          => ok;
singIdLet1 = let x = sing id in x                               => ok;
singIdLet2 = let x = singBis idBis in x                         => ok;
singIdLet3a    = let x :: ['Integer -> 'Integer] = sing id in x => ok;
singIdLet3Err1 = let x :: ['Integer -> 'Bool] = sing id in x    => fail;
singIdLet3b    = let x :: {a} [a -> a] = sing id in x           => ok;
singIdLet3c    = let x :: {a} [[a] -> [a]] = sing id in x       => ok;
singIdLet3Err2 = let x :: {a} [[a] -> 'Maybe a] = sing id in x  => fail;
singIdLet3Err3 = let x :: {a} {b} [a -> b] = sing id in x       => fail;
singIdErr4 :: {a} {b} [a -> b] = sing id                        => fail;

stBind = bindST                                        => ok;
stExample1 = runST (newSTRef 3)                        => ok;
stExample2 = bindST (newSTRef 3) readSTRef             => ok;
stExample3Err = readSTRef (runST (newSTRef 3))         => fail;
stExample4Err = runST (readSTRef (runST (newSTRef 3))) => fail;
stExample5 = runST zas                                 => ok;

otherExample1      = f length => ok;
otherExample2Ambig = f id     => fail;