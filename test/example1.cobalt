import nil    :: {a} [a];;
import cons   :: {a} a -> [a] -> [a];;
import tuple  :: {a} {b} a -> b -> (a,b);;
import fst    :: {a} {b} (a,b) -> a;;
import snd    :: {a} {b} (a,b) -> b;;
import triple :: {a} {b} {c} a -> b -> c -> 'Triple a b c;;
import triplx :: {a} {b = {x} x} {c} a -> b -> c -> 'Triple a b c;;
import tripla :: {a} {b > {x} x -> x} {c} a -> b -> c -> 'Triple a b c;;
import sing   :: {a} a -> [a];;
import id     :: {a} a -> a;;

import bindST    :: {a} {b} {s} {t = a -> 'ST s b} 'ST s a -> t -> 'ST s b;;
import runST     :: {a} {s = {s} 'ST s a} s -> a;;
import newSTRef  :: {a} {s} a -> 'ST s ('STRef s a);;
import readSTRef :: {a} {s} 'STRef s a -> 'ST s a;;
import zas       :: {s} 'ST s 'Integer;;

import f      :: {b} {s = {a} [a] -> b} s -> 'Bool -> b;;
import length :: {a} [a] -> 'Integer;;

checkFunParam1 = \x -> \(y :: {a} a -> a) -> cons (x (tuple y 3)) nil;;
checkFunParam2 = \(x :: {a} a -> a) -> \y -> cons (x (tuple y 3)) nil;;
checkFunApp1 = \x -> \y -> cons (x (tuple y 3)) nil;;
checkFunApp2 = \x -> \y -> cons (x y) nil;;
checkNoChanges = tuple;;

instErr1 = cons 3 2;;
idRoundtrip = \x -> fst (tuple x 3);;
instType1 = \x -> \y -> triple x y 3;;
instType2 = \x -> \(y :: {b} b) -> triplx x y 3;;
instType3Err = \x -> \(y :: {b} b -> b) -> triplx x y 3;;
instType4Err = \x -> \(y :: 'Integer) -> triplx x y 3;;
instType5 = \x -> \(y :: {b} b -> b) -> tripla x y 3;;
instType6Err = \x -> \(y :: 'Integer) -> tripla x y 3;;
instType7 = \x -> \(y :: {b} 'Integer -> b) -> tripla x y 3;;

singBis = \x -> cons x nil;;
idBis = \x -> x;;
intRoundtrip = let x = 3 in x;;

singId1 = sing id;;
singId2 :: {a = {b} b -> b} [a] = let x = sing id in x;;
singId3 :: {a > {b} b -> b} [a] = let x = sing id in x;;
singIdLet1 = let x = sing id in x;;
singIdLet2 = let x = singBis idBis in x;;

stExample1 = runST (newSTRef 3);;
stBind = bindST;;
stExample2 = bindST (newSTRef 3) readSTRef;;
stExample3Err = readSTRef (runST (newSTRef 3));;
stExample3a   = bindST stExample3 (\x -> stExample3);;
stExample4Err = runST (readSTRef (runST (newSTRef 3)));;
stExample5 = runST stExample3;;
stExample6 = runST zas;;

otherExample1      = f length;;
otherExample2Ambig = f id;;

singIdLet3a    = let x :: ['Integer -> 'Integer] = sing id in x;;
singIdLet3Err1 = let x :: ['Integer -> 'Bool] = sing id in x;;
singIdLet3b    = let x :: {a} [a -> a] = sing id in x;;
singIdLet3c    = let x :: {a} [[a] -> [a]] = sing id in x;;
singIdLet3Err2 = let x :: {a} [[a] -> 'Maybe a] = sing id in x;;